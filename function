if nil ~= inBelt and nil ~= outBelt then

    local takeFromSide = NegateSide(splitter.lastInSide)
    local takeToSide = 2
    local InLane = inBelt.get_transport_line(takeFromSide)
    local OutLane = outBelt.get_transport_line(takeToSide)
    
    if Inlane.can_insert_at(0) then
        takeFromSide = NegateSide(takeFromSide)
    end
    
    if not Inlane.can_insert_at(0) then
        locat InLaneItem = InLane.get_contents()
        for itemName,itemCount  in pairs(InLaneContents) do 
            if MoveItems(itemName, itemCount, InLane, OutLane) then
                splitter.lastInSide = takeFromSide
            end
        end
    end
end 


if nil ~= inBelt and nil ~= outBelt then
            for i=1,2 do		
                local takeFromSide = NegateSide(splitter.lastInSide)
                local takeToSide = 2
				
				local InLane = inBelt.get_transport_line(takeFromSide)
                local OutLane = outBelt.get_transport_line(takeToSide)
												
				if InLane.can_insert_at(0) then
					takeFromSide = NegateSide(takeFromSide)
					InLane = inBelt.get_transport_line(takeFromSide)
					OutLane = outBelt.get_transport_line(takeToSide)					
				end	

                if not InLane.can_insert_at(0) then
                    local InLaneContents=InLane.get_contents()	
                    for itemName,itemCount  in pairs(InLaneContents) do 
					    local moved = true
                        if not MoveItems(itemName, itemCount, InLane, OutLane) then 
                            OutLane = outBelt.get_transport_line(takeToSide)
                            if not MoveItems(itemName, itemCount, InLane, OutLane) then
                                moved = false
                            end
                        end
						
						if (moved) then 
							splitter.lastInSide = takeFromSide
							splitter.lastOut[takeFromSide] = takeToSide
						end
                    end
                end
            end
        end